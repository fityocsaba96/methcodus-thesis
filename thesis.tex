\UseRawInputEncoding
\documentclass{elteikthesis}

\title{Methcodus}
\date{2019}
\author{Fityó Csaba}
\degree{programtervező informatikus BSc}
\supervisor{Nagy Sára}
\affiliation{mesteroktató}
\extsupervisor{Czeller Ildikó}
\extaffiliation{adattudós}
\university{Eötvös Loránd Tudományegyetem}
\faculty{Informatikai Kar}
\department{Algoritmusok és Alkalmazásaik}
\departmentSecondLine{Tanszék}
\city{Budapest}
\logo{elte-crest}

\begin{document}

	\documentlang{magyar}

	\maketitle

	\tableofcontents

	\chapter{Bevezetés}

		\section{Motiváció}
		TODO (témaválasztás indoklása)

		\section{Feladatleírás}
		TODO (röviden, közérthetően)

	\chapter{Felhasználói dokumentáció}

		\section{Felhasználási igények}
		TODO (mire való, kik mikor mire használják, összehasonlítás Codewarssal és hagyományos fejlesztőkörnyezettel)
		
		\section{Használati követelmények}
		TODO (rendszerkövetelmények, tudásbeli követelmények, elérési link)
		
		\section{Alkalmazás funkciói}
		TODO (minden funkció leírása képernyőképekkel, külön regisztrált és nem regisztrált felhasználóra, külön helyes és hibás használatra)
		
		\section{Szoftverfejlesztési módszerek}
		TODO (tesztvezérelt fejlesztés, páros programozás bemutatása)

	\chapter{Fejlesztői dokumentáció}

		\section{Probléma specifikáció}
		TODO (célok meghatározása fejlesztői szemmel)

		\section{Tervezés}

			\subsection{Használati esetek}
			TODO (használati eset diagram)
			
			\subsection{Felület terv}
			TODO (mockupok a felületről?)
			
			\subsection{Architektúra terv}
			TODO (rövid leírás a technikai megvalósításról)
		
		\section{Szerver architektúra}

			\subsection{Authentikáció}
			TODO (annak folyamata)
			
			\subsection{Adatbázis}
			TODO (modellek leírása és ábra, kapcsolatok)
			
			\subsection{Végpontok}
			TODO (leírásuk, működésük, kérés és válasz tartalma, hibalehetőségek)
			
			\subsection{Felhasznált technológiák}
			TODO (mit tud, mire és hogyan használom: REST, Node.js, TypeScript, NestJS, TSLint, Nodemon, MongoDB, Docker, Ubuntu, Java, JavaScript, JUnit, Jasmine, Babel, Core.js, WebSocket, Socket.io, Passport, JWT)
			
			\subsection{Kód felépítése}
			TODO (mappaszerkezet, rétegek)
		
		\section{Kliens architektúra}

			\subsection{Authentikáció}
			TODO (annak folyamata)
			
			\subsection{Képernyők}
			TODO (leírásuk, komponenseik)
			
			\subsection{Komponensek}
			TODO (leírásuk, működésük, hibalehetőségek)
			
			\subsection{Felhasznált technológiák}
			TODO (mit tud, mire és hogy használom: Angular, TypeScript, Redux, SPA, CSS, PrimeNG)
			
			\subsection{Kód felépítése}
			TODO (komponensdiagram, mappaszerkezet, rétegek)
		
		\section{Komponensek közti kommunikáció}
		TODO (szerver, kliens és adatbázis összekötés, szekvenciadiagram egy funkcióra)

		\section{A tesztelő rendszer működése}
			Az alkalmazás leglényegesebb része a tesztelő rendszer. A felhasználók által megoldandó programozási feladatok megoldása közben, illetve azok beküldésekor nyújt támpontot számukra azáltal, hogy kiértékeli a megoldásukat és egységes formájú jelentést készít annak állapotáról. Akár tesztvezérelt fejlesztéssel oldja meg a felhasználó a feladatot, akár nem, ez a rendszer felel a megoldás teszteléséért. A tesztelő rendszer a szerveroldalon található, HTTP kapcsolaton keresztül folyik a kommunikáció. Megkapjuk a teszteléshez szükséges adatokat, elvégezzük a teszteket, utána pedig válaszolunk a teszteredményekkel.
			
			Miután megérkeznek HTTP kérésen keresztül a megfelelő adatok, elindítjuk a tesztelést külön folyamatban parancssori programként, a tesztelendő megoldás programozási nyelve szerinti, azon a nyelven írt tesztelő program indításával. Java esetén a \texttt{java}, JavaScript esetén pedig a \texttt{node} parancsot használjuk erre, a teszteléshez szükséges adatokat pedig környezeti változókon keresztül, szövegesen kapja meg a tesztelő. Miután a tesztelő elvégezte feladatát, tudatnia kell az eredményeket az őt hívó szülőfolyamattal. Sikeres tesztelés esetén kiírja a standard kimenetre a teszteredményeket. Hiba esetén kilépési kódokat használunk:
			\begin{itemize}
				\setlength\itemsep{-0.5em}
				\item[1:] a beküldött kódokban lévő szintaktikai hibát jelez
				\item[2:] a beküldött kódokban lévő fordítási hibát jelez
				\item[255:] egyéb, ismeretlen hiba
			\end{itemize}

			A tesztelő folyamat terminálásakor, a szülőfolyamatban kiolvassuk a standard kimenetet, illetve a kilépési kódot. Ezek alapján, illetve hiba esetén egy hibaüzenetet előállítva küldjük vissza a HTTP választ, ami alapján megjelenítjük a felhasználónak a megoldása állapotát. TODO (tesztelésnek a felületen lévő részeiről, egységes formátum alapú módszernél a validációról is írni)
		
			A tesztek futtatására két mód van. Az egyik módszer az egységteszt keretrendszer kódján alapuló tesztelés, másik pedig az egységes formátumon alapuló tesztelés. Mindkét módszer képes együttműködni Java és JavaScript nyelven írt kódokkal.

			\begin{figure}[H]
				\centering
				\includegraphics[scale=0.3333]{staruml/tester-system-class-diagram-1}
				\caption{A tesztelő rendszer osztálydiagramja - 1. rész}
			\end{figure}
			
			\begin{figure}[H]
				\centering
				\includegraphics[scale=0.3333]{staruml/tester-system-class-diagram-2}
				\caption{A tesztelő rendszer osztálydiagramja - 2. rész}
			\end{figure}
			
			\subsection{Egységteszt keretrendszer kódján alapuló tesztelés}
				Ez a tesztelési módszer egy, a feladat megoldására használt programozási nyelvvel együttműködő egységteszt keretrendszert használó tesztkód alapján történő tesztelésre használható. Szükséges hozzá a megoldás kódja, illetve az egységteszt keretrendszert felhasználó tesztkód.
				
				Ezt a módszert akkor használjuk, amikor a felhasználó maga írja a tesztkódot is, azaz a tesztvezérelt fejlesztés, illetve a ping-pong módszer (tesztvezérelt fejlesztés és páros programozás együttesen), mint szoftverfejlesztési módszerek használatával történő megoldáskor.
				
				Célja, hogy a tesztkódban lévő, a megoldást tesztelő teszteseteket lefuttatva jelentést kapjunk azok teljesüléséről.

				\subsubsection{A tesztelés közös lépései}
					\begin{enumerate}
						\item Megkapjuk a tesztelendő megoldás kódját, illetve a tesztkódot.
						\item Létrehozunk egy ideiglenes mappát, amiben a teszteléshez szükséges forráskódokat fogjuk tárolni. A mappa nevének egyedinek kell lennie. Ez biztosítja azt, hogy egyidejűleg több felhasználó is tudja használni az alkalmazást feladatok megoldására, ütközések nélkül. Ennek érdekében a mappanevet a következő minta adja: \texttt{\{HASH\}\_\{TIME\}}, ahol \texttt{\{HASH\}} a megoldás és a teszt forráskódok konkatenációjának az MD5 kódolási algoritmus által képzett kódja, illetve \texttt{\{TIME\}} a jelenlegi Unix-idő milliszekundumokban. Így azonos milliszekundumban is futtatható több tesztelés, amennyiben nem egyeznek meg teljesen a tesztelendő forráskódok.
						\item Kiírjuk a forráskódokat külön fájlokba az előbb létrehozott mappán belül. Egyes programozási nyelveknél fontos lehet, hogy hogyan nevezzük el a fájlokat, ezért erre figyelünk (lásd lentebb, az egyes nyelvek sajátosságainál).
						\item Futtatjuk a tesztkódban lévő teszteket a megfelelő egységteszt keretrendszer segítségével. A teszteseteken belül történő futtatási hibák (exception) esetén sikertelennek nyilvánítjuk az érintett teszteseteket, nem állunk meg a teszteléssel. Bármilyen más, a tesztelés folytatását lehetetlenné tevő hiba (pl. szintaktikai vagy fordítási hiba) esetén megszakítjuk a tesztelési folyamatot, hibával térünk vissza. A tesztek eredményeit egységes, általános formátumban szeretnénk megkapni, erre a JSON szabványt használjuk. Ennek érdekében felüldefiniáljuk az egységteszt keretrendszer alapértelmezett teszteredmény-jelentési módszerét. Ennek értelmében minden teszteset lefutása után legeneráljuk a keretrendszer által adott információk alapján az adott teszteset egységes eredményét, ami a teszteset nevéből és állapotából áll. Egy teszteset állapota lehet sikeres, sikertelen vagy kihagyott. Az összes tesztesetről előáll egy ilyen eredmény. Az így létrehozott JSON objektumot használjuk fel később az eredmények megjelenítésére a felhasználónak. A teszteredmények minta felépítése:
						\begin{minted}{json}
							[
								{ "name": "first test", "status": "pass" },
								{ "name": "second test", "status": "fail" },
								...
							]
						\end{minted}
						\item Végül töröljük a forráskódok tárolására használt ideiglenes mappát. Ezt akkor is megtesszük, ha bármelyik lépésben hiba történik.
					\end{enumerate}

				\subsubsection{Java tesztelés sajátosságai}
					\begin{itemize}
						\item A megoldás, illetve a tesztek fordításához és futtatásához a Java SE Development Kit 13-as verzióját használjuk, egységteszt keretrendszernek pedig a JUnit 5-ös verzióját. A tesztelésre beküldött megoldás és teszt forráskódoknak meg kell felelniük az ezek által támasztott követelményeknek.
						\item Fontos szerepe van Java esetén, hogy a forrásfájlokat milyen néven mentjük el, ennek figyelmen kívül hagyása esetén a fordítási folyamat hibával térne vissza. Ha a forrásfájl osztálystruktúrájának legkülső szintjén van publikus osztály, interfész vagy felsorolási típus, akkor a fájl nevének meg kell egyeznie ennek a nevével. Egyéb esetben nincs megkötés a fájlnévvel kapcsolatban. Ezt a szabályt használjuk fel a fájlnév meghatározásakor. A forráskódban definiált osztálynevek kinyeréséhez a JavaParser Java forráskód elemzőt használjuk. A szintaktikai hibák detektálásához szintén a JavaParser-t használjuk.
						\item Le kell fordítanunk a Java forrásfájlokat, hogy használni tudjuk őket a tesztek futtatásakor. Ehhez a Java Compiler API-t használjuk, ami a Java fordítót használja fel. A lefordított fájlokat a forrásfájlokban opcionálisan deklarálható csomaginformáció szerinti konyvtárstruktúrába helyezzük, a forráskódok ideiglenes mappájába. Ebben a lépésben detektálni tudjuk a fordítási hibákat.
						\item A JUnitnak a tesztesetek lefuttatásához szüksége van az azokat tartalmazó osztályokra, mint objektumokra, és ehhez ezeknek az osztályoknak be kell töltve lenniük a tesztelő program használatára. Legtöbb Java program esetében már futtatáskor meg tudjuk adni az összes, a program által használandó osztályt. Itt nem ez a helyzet, mert a felhasználótól érkező megoldás és teszt csak a program futása alatt kerül használható formába, ezért ezeket futás alatt, dinamikusan kell betöltenünk. Ennek megoldására osztálybetöltőt használunk, amivel be tudjuk tölteni egy lefordított Java fájlokat tartalmazó mappából az osztályokat. Itt még nem vagyunk készen, ugyanis a betöltött osztályok közül meg kell keresnünk azokat, amelyek a felhasználó tesztkódjában lettek definiálva. Ehhez szükségünk van ezeknek az osztályoknak a teljes elérési neveire, ami nem más, mint a teszt forrásfájl osztálystruktúrájának legkülső szintjén lévő osztályok nevei, prefixálva az opcionális csomagnévvel. Ezeknek az információknak a kinyeréséhez szintén a JavaParser-t használjuk. Az így meghatározott elérési nevek alapján már meg tudjuk kapni a hozzájuk tartozó tesztosztályokat az osztálybetöltőből, amit így már fel tud használni a JUnit a tesztek futtatására.
					\end{itemize}

				\subsubsection{JavaScript tesztelés sajátosságai}
					\begin{itemize}
						\item A megoldás, illetve a tesztek futtatásához a Node.js 13-as verzióját használjuk, egységteszt keretrendszernek pedig a Jasmine 3-as verzióját. A tesztelésre beküldött megoldás és teszt forráskódoknak meg kell felelniük az ezek által támasztott követelményeknek.
						\item Bár JavaScript esetén a forráskódokat bármilyen néven elmenthetjük, a konvenció szerinti néven mentjük el őket, a megoldást \texttt{index.js}, a tesztet pedig \texttt{index.spec.js} néven. Ez segíti a megoldó felhasználót, hiszen így a tesztkódban, a megoldás importálásakor nem kell tudnia, hogy honnan kell importálnia, elegendő a jelenlegi mappa elérési útját megadnia, ami \texttt{"."}.
						\item Mivel Node.js 13-as verzióját használjuk a futtatáshoz, így azokat a JavaScript funkciókat, elemeket használhatja a felhasználó, amelyek ebbe be vannak építve. Ezt ki szeretnénk terjeszteni a legújabbakra, ennek érdekében Babel-t és Core.js-t használunk. A Babel feladata, hogy a felhasználó JavaScript forráskódját, amiben a legújabb JavaScript elemek is fel lehetnek használva, átalakítsa olyan JavaScript kóddá, ami működése alapján teljesen megegyezik, viszont az újabb nyelvi elemeket, amelyeket a JavaScriptet futtató környezet még nem támogat, helyettesíti más, megegyező működésű konstrukciókkal. A Core.js feladata pedig, hogy a felhasználó JavaScript kódjában lehetővé tegye olyan osztályok, függvények használatát, amelyek részei, vagy részei lesznek a JavaScript standard függvénytárának, de a futtató környezet még nem tartalmazza ezeket. Ezt úgy éri el, hogy a kódban helyettesíti a megfelelő osztály- és függvényhasználatokat azoknak a Core.js szerinti implementációjával. A felhasználónak a kódban nem kell tennie semmi különöset, a Babel és a Core.js olyan módon került beállításra, hogy a szükséges módosítások a felhasználó forráskódjában automatikusan megtörténnek azok betöltésekor.
						\item A Jasminenak a tesztek futtatásához a teszteseteket tartalmazó fájl elérési útjára van szüksége, amely rendelkezésünkre áll. Az esetleges szintaktikai hibák már a tesztek futtatásakor derülnek ki.
					\end{itemize}

			\subsection{Egységes formátumon alapuló tesztelés}
				Ez a tesztelési módszer programozási nyelv-független, egységes formátumú tesztesetek alapján történő tesztfuttatást tesz lehetővé. Ez azt jelenti, hogy ha van egy programozási feladatra egy-egy teljesen megegyező megoldásom két különböző programozási nyelven, illetve vannak ilyen, egységes formátumú teszteseteim ezekhez a megoldásokhoz, akkor bármely programozási nyelven írt megoldásra lefuttatva a teszteket, azonos eredményeket kapok. Ennek eléréséhez egy olyan, közös interfészre van szükség, amely minden támogatott programozási nyelven megvalósítható. Ennek értelmében a teszteket nem egy programozási nyelv kódjaként írjuk meg, hanem definiálunk egy sémát a JSON szabvány felhasználásával, amely sémában reprezentálni tudjuk a tesztjeinket. A tesztek futtatásakor ezt a JSON objektumot át kell alakítanunk a tesztelendő megoldás programozási nyelve szerinti egységteszt keretrendszer kódjává, amellyel már le tudjuk futtatni a teszteket. Ehhez a JSON struktúrában lévő adatoknak egyértelműen megfeleltethetőnek kell lenniük a cél egységteszt keretrendszerben használható konstrukciónak. Ehhez a módszerhez szükséges a megoldás kódja, illetve a egységes teszteket tartalmazó JSON struktúra.
				
				Ezt a módszert minden esetben használjuk, de más módon. Amikor a felhasználó csak a megoldás kódját írja, azaz normál mód, illetve páros programozás, mint szoftverfejlesztési módszer használatakor, akkor úgy használjuk ezt a módszert, hogy a feladatot létrehozó felhasználó által a létrehozáskor megadott egységes formátumú teszteket küldjük be tesztelésre a megoldó felhasználó megoldási kódjával együtt, amikor a felhasználó tesztelést kér. Egyéb esetekben, vagyis a tesztvezérelt fejlesztés és a ping-pong módszer, mint szoftverfejlesztési módszerek használatakor bár a felhasználó maga írja a tesztkódot is, de a megoldás tényleges megfelelőségének ellenőrzése céljából lefutnak a létrehozáskor meghatározott egységes formátumú tesztek is.
				
				A módszer célja, hogy a megoldáskor egységes formában meg tudjuk jeleníteni, hogy milyen elvárásoknak kell megfelelni, az egységes teszteseteket lefuttatva jelentést kapjunk azok teljesüléséről, illetve, hogy a feladatot létrehozó felhasználónak csak egyszer kelljen leírnia a teszteseteket és az működjön minden programozási nyelvvel.

				A JSON struktúra tartalmazza az egységes formátumú teszteseteket és a tesztelendő függvény meghívási kódját. Ez a kód nem más, mint ahogyan a megoldásfüggvényünket meghívnánk az adott programozási nyelven, de még paraméterek nélkül, és ezt a megoldó felhasználónak kell megadnia a tesztelendő függvény beazonosítása érdekében. A teszteseteknél minden egyes tesztesethez tartozik egy szöveges leírás, egy paraméterlista, egy összehasonlító művelet és az elvárt érték. Az összehasonlító művelet lehet egyenlőség- vagy nem-egyenlőség vizsgálat. A paraméterekhez és az elvárt értékhez tartozik egy típus és egy érték. Típus lehet egész szám, dupla pontosságú lebegőpontos szám, logikai érték, szöveges érték, egész számok tömbje, dupla pontosságú lebegőpontos számok tömbje, logikai értékek tömbje vagy szöveges értékek tömbje. Az értékeknek a típus által támasztott szabályoknak kell megfelelniük, a tömböknél az egyes elemek "|" karakterrel vannak elválasztva. Egy lehetséges minta felépítés:
				\begin{minted}{json}
					{
						"functionCallCode": "calculateSomething",
						"testCases": [
							{
								"description": "it should return the ...",
								"parameters": [
									{
										"type": "integer",
										"value": "2"
									},
									{
										"type": "string array",
										"value": "one|two|three|four"
									},
									...
								],
								"matcher": "not equals",
								"expected": {
									"type": "boolean",
									"value": "true"
								}
							},
							...
						]
					}
				\end{minted}

				\subsubsection{A tesztelés közös lépései}
					\begin{enumerate}
						\item Megkapjuk a megoldás kódját, illetve az egységes, JSON formátumú tesztadatokat.
						\item Az egységes formátumú teszteseteket átalakítjuk a megoldáshoz használt programozási nyelv szerinti egységteszt keretrendszert felhasználó tesztkóddá:
						\begin{enumerate}
							\item Beillesztünk olyan kódokat, amelyek beimportálják a tesztkód számára szükséges függőségeket, így lehetővé teszik használatukat. Ez programozási nyelvenként változik.
							\item Előállítjuk minden egységes tesztesetnek az egységteszt keretrendszerbeli megfelelőjét. Pontosan megfeleltetünk minden megadható összehasonlító műveletet, illetve literált az egységteszt keretrendszerben, illetve a programozási nyelvben használható megfelelőjével. A tömbliterálok megfeleltetésénél az egyes elemeinek meghatározásához azoknak a megfeleltetését használjuk fel. Szöveges literáloknál figyelünk arra, hogy a nyelv sajátosságainak megfelelően escapeljük a benne lévő karaktereket az előállított forráskódban, így bármilyen karakter használható értékként. Tömb literáloknál lehetőséget adunk arra, hogy az elválasztó karaktert is fel lehessen használni az értékekben azáltal, hogy az escapelt elválasztókat nem elválasztóknak, hanem annak megfelelő karaktereknek feleltetjük meg. Ezek használatával már meghatározhatóak a szöveges leírások, a paraméterlisták, az összehasonlító műveletek és az elvárt értékek, így felépíthetőek a tesztesetek kódjai.
						\end{enumerate}
						\item A így létrejövő teszt- és az eredeti megoldáskód felhasználásával ugyanaz a folyamat megy végbe, mint az egységteszt keretrendszer kódján alapuló tesztelés módszerénél.
					\end{enumerate}

				\subsubsection{Java tesztelés sajátosságai}
					\begin{itemize}
						\item Az átalakítás során a JUnitot felhasználó tesztkód kerül előállításra.
						\item Importálásnál szükségünk van a JUnitból felhasználandó elemekre és Java osztályokra.
						\item Az összehasonlító műveletek megfeleltethetőségének megkönnyítése érdekében legeneráljuk és beillesztjük a kódba olyan összehasonlító műveletek implementációját, amelyeket a JUnit nem tartalmaz, viszont szükségünk van rájuk az egységes formátum maradéktalan támogatása érdekében.
					\end{itemize}
								
				\subsubsection{JavaScript tesztelés sajátosságai}
					\begin{itemize}
						\item Az átalakítás során a Jasminet felhasználó tesztkód kerül előállításra.
						\item Be kell importálnunk a megoldás kódjában lévő, exportált elemeket. A JavaScript nem ad natív lehetőséget arra, hogy kizárólag a fájlnév alapján beimportáljunk abból mindent, fel kell tudnunk sorolni egyesével az importálandó elemeket. Ennek feloldásaként azt a trükköt alkalmazzuk, hogy olyan kódot illesztünk be a tesztkódba, amely lefutásakor lekérdezi a megoldás fájljából exportált elemek nevét és értékét, és ezeket felhasználva elérhetővé teszi őket a tesztkódban. A megoldás CommonJS és ES6 modulrendszert használva is működik.
					\end{itemize}

		\section{Fejlesztőkörnyezet}

			\subsection{Rendszerkövetelmények}
				A szerver, illetve a kliens futtatásához szükséges szoftverek:
				\begin{itemize}
					\setlength\itemsep{-0.5em}
					\item Docker futtatására alkalmas operációs rendszer (Windows, macOS vagy Linux)
					\item Docker Desktop (2.0.0.0 vagy újabb verzió)
					\item Make (opcionális) (3.81 vagy újabb verzió)
				\end{itemize}

				Az alkalmazás közvetlenül használt függőségei nem szükségesek, azok Docker konténerek segítségével állnak rendelkezésre.

			\subsection{Fejlesztőkörnyezet beállítása}
				Másoljuk a DVD melléklet tartalmát számítógépre, majd nyissunk egy terminál ablakot a szerver mappájában (\texttt{methcodus-server}). Indítsuk el a szerver telepítését:
				\mint{shell}|$ make all|

				Ezzel minden beállításra kerül, ami a szerver használatához szükséges:
				\begin{itemize}
					\item Létrejön a szerver futtatására képes Docker konténer, amely rendelkezik az alkalmazás által támogatott programozási nyelveken íródott forráskódok futtatásához szükséges szoftverekkel.
					\item A konténerben telepítésre kerülnek a tesztelő rendszerek függőségei, vagyis JavaScript esetén Jasmine és Babel, Java esetén pedig JUnit, JavaParser és JSON-Java, illetve lefordításra kerül a Java tesztelő kódja.
					\item A konténerben telepítésre kerülnek a szerver alkalmazás függőségei.
					\item Létrejön a MongoDB adatbázis futtatására képes Docker konténer.
					\item Elindul a két konténer. Egyik elindítja az alkalmazás szerverét a 3000-es porton fejlesztői üzemmódban, a másik pedig az adatbázis szervert. Ezután mindkét szerver elérhető lesz közvetlenül a konténereket futtató számítógépről is, illetve az alkalmazás szerver újra fog indulni fájlmódosítás esetén.
				\end{itemize}

				A szervert elérhetjük a \url{http://localhost:3000} címen, kipróbálhatjuk annak API-ját például egy API tesztelő szoftver segítségével. A terminálban lépjünk át a kliens könyvtárába (\texttt{methcodus-client}), és indítsuk el a kliens telepítését is:
				\mint{shell}|$ make all|

				Csakúgy mint a szerver esetében, ezzel minden előkészítésre kerül, ami a kliens használatához szükséges:
				\begin{itemize}
					\item Létrejön a kliens futtatására képes Docker konténer.
					\item A konténerben telepítésre kerülnek a kliens alkalmazás függőségei.
					\item Elindul a konténer. Elindítja az alkalmazás kliensét a 4200-as porton fejlesztői üzemmódban. Ezután elérhető lesz közvetlenül a konténert futtató számítógépről is, illetve az alkalmazás szerver újra fog indulni fájlmódosítás esetén.
				\end{itemize}

				Ezek után nyissuk meg egy böngészőben a \url{http://localhost:4200} oldalt, ahol elérhető és használható a kliens alkalmazás. A szerver, illetve a kliens alkalmazás mappájából kiadható néhány, fejlesztés közben hasznos parancs:
				\begin{center}
					\begin{tabularx}{\textwidth}{l>{\RaggedRight}X}
						\texttt{\$ make build} & az alkalmazást futtató konténer(ek) létrehozása/frissítése \\
						\texttt{\$ make install} & az alkalmazás konténerében a függőségek telepítése/frissítése \\
						\texttt{\$ make start} & az alkalmazás konténer(ei)nek elindítása \\
						\texttt{\$ make stop} & az alkalmazás konténer(ei)nek leállítása \\
						\texttt{\$ make destroy} & az alkalmazás konténer(ei)nek törlése \\
						\texttt{\$ make npm script=\{SCRIPT\}} & az alkalmazás konténerében a \{SCRIPT\} nevű npm script lefuttatása \\
						\texttt{\$ make ssh service=\{SERVICE\}} & az alkalmazás \{SERVICE\} nevű konténerjének shelljébe való belépés
					\end{tabularx}	
				\end{center}
				
		\section{Fejlesztési folyamat}

			\subsection{Konténerizálás}

				\subsubsection{Konténerek}
					Az alkalmazás szerverének és kliensének a fejlesztése konténerekben történik. Egy konténer egy szabványos szoftveregység, ami tartalmazza egy alkalmazás kódját és annak a fejlesztéséhez és futtatásához szükséges összes függőséget, beleértve az operációs rendszert, a szükséges rendszereszközöket, beállításokat, illetve az alkalmazás fejlesztését és futtatását lehetővé tevő rendszereket. Általában érdemes arra törekedni, hogy egy konténer minél kisebb méretű legyen, amit úgy érhetünk el, hogy olyan operációs rendszert választunk kiindulásnak, ami nem tartalmaz túl sok olyan szoftvert, amit nem használ az alkalmazásunk, illetve csak olyan szoftvereket telepítünk, amelyeket az alkalmazásunk valamilyen formában felhasznál. Minden alkalmazásnak más lehet az ideális környezet és általában azt szeretnénk, hogy az alkalmazások függetlenül működjenek egymástól, ezért ajánlatos konténerenként csak egy alkalmazást futtatni. A konténerizált alkalmazások elszigeteltségük miatt általában gyorsabban és megbízhatóbban működnek, mint hagyományos társaik, illetve nem szükséges a használatukhoz semmilyen szoftver a konténereket futtatni képes platformon kívül. Ezen kívül pedig operációs rendszer függetlenek is az ilyen alkalmazások, minden infrastruktúrán ugyanúgy működnek.

					A konténerek hasonlóak a virtuális gépekhez. Legfőbb különbség köztük, hogy a konténerek a szoftvert virtualizálják, a virtuális gépek pedig a hardvert. Emiatt óriási méretbeli és teljesítménybeli különbségek vannak a konténerek javára.

					A Docker egy szoftver konténerek létrehozására és futtatására. Egy konténer leírása \texttt{Dockerfile} fájlban történik. Itt adhatók meg olyan konfigurációk, mint a kiindulási operációs rendszer, a konténer létrehozásakor a függőségek telepítéséhez és a rendszer megfelelő beállításához lefuttatandó shell parancsok, a forrás számítógépről a konténerbe átmásolandó fájlok és a konténer indításakor futtatandó shell parancs. Emellett megadható \texttt{docker-compose.yml} fájl is, amely többkonténeres alkalmazások definiálására, illetve a konténerek futtatásához kapcsolódó beállítások megadására szolgál, mint például környezeti változók megadása, a forrás számítógépről logikai meghajtók felcsatlakoztatása, portok és hálózatok definiálása. Dockert használunk a szerver és kliens alkalmazás konténerizálására. Mivel az alkalmazások teljeskörűen konténerizáltak, csak Dockerre van szükség a fejlesztéshez és futtatáshoz.

				\subsubsection{Az alkalmazás konténerizálása}
					Az alkalmazás három konténerből épül fel: adatbázis, szerver és kliens. A konténerek közös hálózatra vannak kötve, így el tudják érni egymást. Az alábbiakban ezen konténerek működése olvasható.

					Adatbázis:
					\begin{itemize}
						\setlength\itemsep{-0.5em}
						\item Az adatbázis konténere egy előre elkészített konténer, ami MongoDB 3.6.9 adatbázist futtat.
						\item Elérhetővé tesszük a konténerben futó adatbázishoz való hozzáférést a 27017-es porton.
						\item Az adatbázis adatainak tárolására megadunk egy kötetet.
					\end{itemize}

					Szerver:
					\begin{itemize}
						\setlength\itemsep{-0.5em}
						\item A szerver konténerizálásához az Ubuntu 18.04 operációs rendszerből indulunk ki.
						\item Telepítjük a Node.js 13-as verzióját, illetve a Java SE Development Kit 13-as verzióját, amelyekre a tesztelő rendszereknek is, és magának az alkalmazásnak is szükségük van.
						\item Létrehozunk root jogokkal nem rendelkező felhasználót, ő fogja futtatni a szoftvert.
						\item Elérhetővé tesszük a konténerben futó alkalmazáshoz való hozzáférést a 3000-es porton.
						\item Beállítjuk a szükséges környezeti változókat, mint például a használandó portot és az adatbázis elérhetőségét.
						\item Felcsatoljuk a konténerbe az alkalmazás kódját tartalmazó mappát.
						\item Elindítjuk az alkalmazást fejlesztői módban.
					\end{itemize}

					Kliens:
					\begin{itemize}
						\setlength\itemsep{-0.5em}
						\item Szintén Ubuntu 18.04-ből indulunk ki.
						\item Telepítjük a Node.js 13-as verzióját, ami az alkalmazást futtatni fogja.
						\item Itt is létrehozzuk a root jogok nélküli felhasználót, elérhetővé tesszük a konténeren kívüli hozzáférést a 4200-as porton, beállítjuk a szerver elérhetőségét környezeti változóként, felcsatoljuk a kódot tartalmazó mappát, illetve elindítjuk az alkalmazás fejlesztői módját.
					\end{itemize}

			\subsection{Csomagkezelés}
				A csomagkezelés olyan tevékenység, amely során meghatározásra kerülnek, illetve beszerzésre kerülnek az alkalmazás futtatásához szükséges függőségek. Node.js alkalmazásokhoz a legelterjedtebb és legtöbb csomaggal rendelkező csomagkezelő rendszer az npm (Node Package Manager). Az npm esetén egy \texttt{package.json} nevű fájlban lehet meghatározni a függőségeket, scripteket lehet írni a fejlesztés könnyítése céljából, illetve különböző olyan beállításokat lehet megadni, amelyek leginkább akkor jönnek jól, ha közzé akarjuk tenni az alkalmazásunkat csomag formájában az npm-en. A függőségek megadhatók fejlesztési idejű függőségként vagy normál függőségként. Az npm egyben egy CLI eszköz is, amely a \texttt{package.json} fájlból dolgozva többek között telepíteni tudja az abban megadott függőségeket, illetve futtatni tudja a megadott scripteket. A szerver és a kliens alkalmazás függőségeinek kezelésére npm-et használ.
			
			\subsection{Verziókövetés}
				Az alkalmazás fejlesztése során a Git verziókövető rendszert használtam. Három különböző repositoryt hoztam létre, egyik a szerver kódját tartalmazza (\texttt{methcodus-server}), másik a kliens kódját (\texttt{methcodus-client}), harmadik pedig a dokumentáció kódját (\texttt{methcodus-thesis}). A Conventional Commits specifikációt használtam a commit üzenetek strukturált megírására. A GitHub egy Git-et használó online verziókövető platform. A repositoryk GitHub-on is elérhetőek a \url{https://github.com/users/fityocsaba96/projects/1} címen.
			
			\subsection{Continuous Integration}
				A Continuous Integration (CI) az a folyamat, amely a központi kódtárba került kódváltozásokat folyamatosan, automatizáltan képes letesztelni és tovább küldeni az éles rendszerbe való integrálás céljából, amennyiben az megfelel a támasztott követelményeknek. Ez azt jelenti, hogy amint kódváltozás történik, a felhasználók azt szinte azonnal, automatikusan megkapják, így mindig a működő legfrissebb változatot használhatják és nem kell hosszú időket várni az egyes újabb verziók megjelenésére. Egy ilyen rendszer úgy működik, hogy amikor kódváltozást észlel (például új commit érkezik a verziókövető rendszerbe), akkor előkészít egy megfelelő környezetet a kód futtatására a kód legfrissebb változatával együtt, és lefuttat a kóddal kapcsolatban előre megadott parancsokat, amelyekkel a kód működését, minőségét ellenőrzi. Ezek sikertelensége esetén nem történik semmi, ellenkező esetben viszont a kód további folyamatoknak lesz átadva, ahol kikerül éles környezetbe, használatra kész állapotra lesz hozva. Ezt nevezzük deploymentnek.

				A Codeship egy hosztolt, felhőalapú, CI folyamatokat támogató szolgáltatás. Codeshipet használunk mind a szerver, mind a kliens alkalmazás esetén. Amikor commit érkezik a GitHub repository master ágába, lefuttatja a CI folyamatot. A következőkben az alkalmazás CI folyamatai olvashatók.

				Szerver:
				\begin{itemize}
					\setlength\itemsep{-0.5em}
					\item Lemásoljuk a legfrissebb kódbázist egy elkülönített környezetbe.
					\item Telepítjük a Node.js 13-as verzióját, illetve a Java SE Development Kit 13-as verzióját, amelyekre a folyamat további lépéseiben szükségünk van.
					\item Telepítjük az alkalmazás függőségeit. Ezek cachelésre kerülnek, azaz legközelebb nem kell minden függőséget újra telepíteni.
					\item Lebuildeljük az alkalmazást, hogy például a fordítást hibákat és egyéb figyelmetlenségeket kiszűrjük.
					\item Statikus kódellenőrzést futtatunk TSLint segítségével, amellyel stilisztikai, esztétikai és kódminőségi hibákat szűrhetünk ki.
					\item Lefuttatjuk az alkalmazáshoz írt egységteszteket, amivel biztosítjuk a tesztelt egységek megfelelő működését.
					\item Átadjuk a működő kódbázisunkat a Herokunak, ahol az deployolásra kerül.
				\end{itemize}

				Kliens:
				\begin{itemize}
					\setlength\itemsep{-0.5em}
					\item Szintén lemásoljuk az új kódbázist.
					\item Telepítjük a Node.js 13-as verzióját, amelyekre a folyamat további lépéseiben szükségünk van.
					\item Itt is telepítjük a függőségeket, lebuildeljük az alkalmazást, lefuttatjuk a statikus kódellenőrzést, illetve átadjuk a kódbázist deployolásra.
				\end{itemize}
			
			\subsection{Continuous Delivery}
			TODO (Herokuról írni)
		
		\section{Tesztelés}
		TODO (rövid bevezetés)

			\subsection{Egységtesztek}
				A megoldás tesztelő rendszerhez egységtesztek készültek. Ezek a tesztek minden részletét letesztelik mind az egységteszt keretrendszer kódján alapuló, mind az egységes formátumon alapuló tesztelési módszernek. A programozási nyelvektől független működésű tesztesetek Java és JavaScript nyelvek használata esetén is meg lettek fogalmazva, ezen kívül le lettek tesztelve a programozási nyelv-specifikus esetek is. A tesztek a \texttt{methcodus-server/src/tester/tester.service.spec.ts} fájlban találhatóak, összesen 60 darab egységtesztet tartalmaz. A tesztek írására a Jasmine nevű egységteszt keretrendszert használtam. A leglényegesebb, letesztelt esetek a következőek:
				\begin{itemize}
					\item Egységteszt keretrendszer kódján alapuló tesztelés:
					\begin{itemize}
						\setlength\itemsep{-0.5em}
						\item Sikeres, sikertelen, illetve kihagyott állapotú tesztesetek
						\item Üres kód beküldése sikerrel, nulla teszteredménnyel végződik
						\item Egymásba ágyazott tesztstruktúrákon belüli tesztek is lefutnak
						\item JavaScript kódokban használható a CommonJS és az ES6 modulrendszer is, illetve minden modern JavaScript nyelvi elem és funkció
						\item Java kódokban használhatóak a csomagnevek
						\item Az ideiglenes forráskódokat tartalmazó mappa minden esetben kitörlődik
						\item Kivétel esetén sikertelen állapot
						\item Szintaktikai hiba, fordítási hiba és más hibák esetén hibaüzenet
					\end{itemize}
					\item Egységes formátumon alapuló tesztelés:
					\begin{itemize}
						\setlength\itemsep{-0.5em}
						\item Bármilyen támogatott paraméter típust elváró és önmagát visszaadó egyparaméteres függvény tesztelése a megfelelő eredménnyel zárul, bármely összehasonlító művelet esetén, igaz és hamis eredményt elváró esetekben is
						\item Nulla-, egy- és többparaméteres függvények is tesztelhetőek
						\item JavaScript megoldás kódból beimportáljuk, amik exportálva lettek
						\item Szöveges literálokat escapeljük, tömb literálokat escapelt elválasztó karakter esetén nem vágjuk el
					\end{itemize}
				\end{itemize}
			
			\subsection{Manuális tesztek}
			TODO (minden funkció lényegesebb kimeneteleire given-when-then leírás)
		
		\section{Továbbfejlesztési lehetőségek}
		TODO (Clean Code elvek támogatása, élő menet, élő menet páros programozással)

	\begin{thebibliography}{99}

		\addcontentsline{toc}{chapter}{Irodalomjegyzék}

		\bibitem{test} 
		\href{http://example.com}{TODO (kitölteni)} (2019.04.06.)

	\end{thebibliography}
	
	\chapter*{Mellékletek}

	\pagenumbering{gobble}
	\addcontentsline{toc}{chapter}{Mellékletek}

	\section*{DVD tartalma}
	TODO (tartalom, mappaszerkezet)

\end{document}
