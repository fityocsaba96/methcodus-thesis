\UseRawInputEncoding
\documentclass{elteikthesis}

\title{Methcodus}
\date{2019}
\author{Fityó Csaba}
\degree{programtervező informatikus BSc}
\supervisor{Nagy Sára}
\affiliation{mesteroktató}
\extsupervisor{Czeller Ildikó}
\extaffiliation{adattudós}
\university{Eötvös Loránd Tudományegyetem}
\faculty{Informatikai Kar}
\department{Algoritmusok és Alkalmazásaik}
\departmentSecondLine{Tanszék}
\city{Budapest}
\logo{elte-crest}

\begin{document}

	\documentlang{magyar}

	\maketitle

	\tableofcontents

	\chapter{Bevezetés}

		\section{Motiváció}
		TODO (témaválasztás indoklása)

		\section{Feladatleírás}
		TODO (röviden, közérthetően)

	\chapter{Felhasználói dokumentáció}

		\section{Felhasználási igények}
		TODO (mire való, kik mikor mire használják, összehasonlítás Codewarssal és hagyományos fejlesztőkörnyezettel)
		
		\section{Használati követelmények}
		TODO (rendszerkövetelmények, tudásbeli követelmények, elérési link)
		
		\section{Alkalmazás funkciói}
		TODO (minden funkció leírása képernyőképekkel, külön regisztrált és nem regisztrált felhasználóra, külön helyes és hibás használatra)
		
		\section{Szoftverfejlesztési módszerek}
		TODO (tesztvezérelt fejlesztés, páros programozás bemutatása)

	\chapter{Fejlesztői dokumentáció}

		\section{Probléma specifikáció}
		TODO (célok meghatározása fejlesztői szemmel)

		\section{Tervezés}

			\subsection{Használati esetek}
			TODO (használati eset diagram)
			
			\subsection{Felület terv}
			TODO (mockupok a felületről?)
			
			\subsection{Architektúra terv}
			TODO (rövid leírás a technikai megvalósításról)
		
		\section{Szerver architektúra}

			\subsection{Authentikáció}
			TODO (annak folyamata)
			
			\subsection{Adatbázis}
			TODO (modellek leírása és ábra, kapcsolatok)
			
			\subsection{Végpontok}
			TODO (leírásuk, működésük, kérés és válasz tartalma, hibalehetőségek)
			
			\subsection{Felhasznált technológiák}
			TODO (mit tud, mire és hogyan használom: REST, Node.js, TypeScript, NestJS, MongoDB, Docker, Ubuntu, Java, JavaScript, JUnit, Jasmine, Babel, Core.js, WebSocket, Socket.io, Passport, JWT)
			
			\subsection{Kód felépítése}
			TODO (mappaszerkezet, rétegek)
		
		\section{Kliens architektúra}

			\subsection{Authentikáció}
			TODO (annak folyamata)
			
			\subsection{Képernyők}
			TODO (leírásuk, komponenseik)
			
			\subsection{Komponensek}
			TODO (leírásuk, működésük, hibalehetőségek)
			
			\subsection{Felhasznált technológiák}
			TODO (mit tud, mire és hogy használom: Angular, TypeScript, Redux, SPA, Emarsys design system)
			
			\subsection{Kód felépítése}
			TODO (komponensdiagram, mappaszerkezet, rétegek)
		
		\section{Komponensek közti kommunikáció}
		TODO (szerver, kliens és adatbázis összekötés, szekvenciadiagram egy funkcióra)

		\section{A tesztelő rendszer működése}
			Az alkalmazás leglényegesebb része a tesztelő rendszer. A felhasználók által megoldandó programozási feladatok megoldása közben, illetve azok beküldésekor nyújt támpontot számukra azáltal, hogy kiértékeli a megoldásukat és egységes formájú jelentést készít annak állapotáról. Akár tesztvezérelt fejlesztéssel oldja meg a felhasználó a feladatot, akár nem, ez a rendszer felel a megoldás teszteléséért. A tesztelő rendszer a szerveroldalon található, HTTP kapcsolaton keresztül folyik a kommunikáció. Megkapjuk a teszteléshez szükséges adatokat, elvégezzük a teszteket, utána pedig válaszolunk a teszteredményekkel.
			
			Miután megérkeznek HTTP kérésen keresztül a megfelelő adatok, elindítjuk a tesztelést külön folyamatban parancssori programként, a tesztelendő megoldás programozási nyelve szerinti, azon a nyelven írt tesztelő program indításával. Java esetén a \texttt{java}, JavaScript esetén pedig a \texttt{node} parancsot használjuk erre, a teszteléshez szükséges adatokat pedig környezeti változókon keresztül, szövegesen kapja meg a tesztelő. Miután a tesztelő elvégezte feladatát, tudatnia kell az eredményeket az őt hívó szülőfolyamattal. Sikeres tesztelés esetén kiírja a standard kimenetre a teszteredményeket. Hiba esetén kilépési kódokat használunk:
			\begin{itemize}
				\setlength\itemsep{-0.5em}
				\item[1:] a beküldött kódokban lévő szintaktikai hibát jelez
				\item[2:] a beküldött kódokban lévő fordítási hibát jelez
				\item[255:] egyéb, ismeretlen hiba
			\end{itemize}
			A tesztelő folyamat terminálásakor, a szülőfolyamatban kiolvassuk a standard kimenetet, illetve a kilépési kódot. Ezek alapján, illetve hiba esetén egy hibaüzenetet előállítva küldjük vissza a HTTP választ, ami alapján megjelenítjük a felhasználónak a megoldása állapotát. TODO (tesztelésnek a felületen lévő részeiről, egységes formátum alapú módszernél a validációról is írni)
		
			A tesztek futtatására két mód van. Az egyik módszer az egységteszt keretrendszer kódján alapuló tesztelés, másik pedig az egységes formátumon alapuló tesztelés. Mindkét módszer képes együttműködni Java és JavaScript nyelven írt kódokkal.

			\begin{figure}[H]
				\centering
				\includegraphics[scale=0.3333]{staruml/tester-system-class-diagram-1}
				\caption{A tesztelő rendszer osztálydiagramja - 1. rész}
			\end{figure}
			
			\begin{figure}[H]
				\centering
				\includegraphics[scale=0.3333]{staruml/tester-system-class-diagram-2}
				\caption{A tesztelő rendszer osztálydiagramja - 2. rész}
			\end{figure}
			
			\subsection{Egységteszt keretrendszer kódján alapuló tesztelés}
				Ez a tesztelési módszer egy, a feladat megoldására használt programozási nyelvvel együttműködő egységteszt keretrendszert használó tesztkód alapján történő tesztelésre használható. Szükséges hozzá a megoldás kódja, illetve az egységteszt keretrendszert felhasználó tesztkód.
				
				Ezt a módszert akkor használjuk, amikor a felhasználó maga írja a tesztkódot is, azaz a tesztvezérelt fejlesztés, illetve a ping-pong módszer (tesztvezérelt fejlesztés és páros programozás együttesen), mint szoftverfejlesztési módszerek használatával történő megoldáskor.
				
				Célja, hogy a tesztkódban lévő, a megoldást tesztelő teszteseteket lefuttatva jelentést kapjunk azok teljesüléséről.

				\subsubsection{A tesztelés közös lépései}
					\begin{enumerate}
						\item Megkapjuk a tesztelendő megoldás kódját, illetve a tesztkódot.
						\item Létrehozunk egy ideiglenes mappát, amiben a teszteléshez szükséges forráskódokat fogjuk tárolni. A mappa nevének egyedinek kell lennie. Ez biztosítja azt, hogy egyidejűleg több felhasználó is tudja használni az alkalmazást feladatok megoldására, ütközések nélkül. Ennek érdekében a mappanevet a következő minta adja: \texttt{\{HASH\}\_\{TIME\}}, ahol \texttt{\{HASH\}} a megoldás és a teszt forráskódok konkatenációjának az MD5 kódolási algoritmus által képzett kódja, illetve \texttt{\{TIME\}} a jelenlegi Unix-idő milliszekundumokban. Így azonos milliszekundumban is futtatható több tesztelés, amennyiben nem egyeznek meg teljesen a tesztelendő forráskódok.
						\item Kiírjuk a forráskódokat külön fájlokba az előbb létrehozott mappán belül. Egyes programozási nyelveknél fontos lehet, hogy hogyan nevezzük el a fájlokat, ezért erre figyelünk (lásd lentebb, az egyes nyelvek sajátosságainál).
						\item Futtatjuk a tesztkódban lévő teszteket a megfelelő egységteszt keretrendszer segítségével. A teszteseteken belül történő futtatási hibák (exception) esetén sikertelennek nyilvánítjuk az érintett teszteseteket, nem állunk meg a teszteléssel. Bármilyen más, a tesztelés folytatását lehetetlenné tevő hiba (pl. szintaktikai vagy fordítási hiba) esetén megszakítjuk a tesztelési folyamatot, hibával térünk vissza. A tesztek eredményeit egységes, általános formátumban szeretnénk megkapni, erre a JSON szabványt használjuk. Ennek érdekében felüldefiniáljuk az egységteszt keretrendszer alapértelmezett teszteredmény-jelentési módszerét. Ennek értelmében minden teszteset lefutása után legeneráljuk a keretrendszer által adott információk alapján az adott teszteset egységes eredményét, ami a teszteset nevéből és állapotából áll. Egy teszteset állapota lehet sikeres, sikertelen vagy kihagyott. Az összes tesztesetről előáll egy ilyen eredmény. Az így létrehozott JSON objektumot használjuk fel később az eredmények megjelenítésére a felhasználónak. A teszteredmények minta felépítése:
						\begin{minted}{json}
							[
								{ "name": "first test", "status": "pass" },
								{ "name": "second test", "status": "fail" },
								...
							]
						\end{minted}
						\item Végül töröljük a forráskódok tárolására használt ideiglenes mappát. Ezt akkor is megtesszük, ha bármelyik lépésben hiba történik.
					\end{enumerate}

				\subsubsection{Java tesztelés sajátosságai}
					\begin{itemize}
						\item A megoldás, illetve a tesztek fordításához és futtatásához a Java SE Development Kit 12-es verzióját használjuk, egységteszt keretrendszernek pedig a JUnit 5-ös verzióját. A tesztelésre beküldött megoldás és teszt forráskódoknak meg kell felelniük az ezek által támasztott követelményeknek.
						\item Fontos szerepe van Java esetén, hogy a forrásfájlokat milyen néven mentjük el, ennek figyelmen kívül hagyása esetén a fordítási folyamat hibával térne vissza. Ha a forrásfájl osztálystruktúrájának legkülső szintjén van publikus osztály, interfész vagy felsorolási típus, akkor a fájl nevének meg kell egyeznie ennek a nevével. Egyéb esetben nincs megkötés a fájlnévvel kapcsolatban. Ezt a szabályt használjuk fel a fájlnév meghatározásakor. A forráskódban definiált osztálynevek kinyeréséhez a JavaParser Java forráskód elemzőt használjuk. A szintaktikai hibák detektálásához szintén a JavaParser-t használjuk.
						\item Le kell fordítanunk a Java forrásfájlokat, hogy használni tudjuk őket a tesztek futtatásakor. Ehhez a Java Compiler API-t használjuk, ami a Java fordítót használja fel. A lefordított fájlokat a forrásfájlokban opcionálisan deklarálható csomaginformáció szerinti konyvtárstruktúrába helyezzük, a forráskódok ideiglenes mappájába. Ebben a lépésben detektálni tudjuk a fordítási hibákat.
						\item A JUnitnak a tesztesetek lefuttatásához szüksége van az azokat tartalmazó osztályokra, mint objektumokra, és ehhez ezeknek az osztályoknak be kell töltve lenniük a tesztelő program használatára. Legtöbb Java program esetében már futtatáskor meg tudjuk adni az összes, a program által használandó osztályt. Itt nem ez a helyzet, mert a felhasználótól érkező megoldás és teszt csak a program futása alatt kerül használható formába, ezért ezeket futás alatt, dinamikusan kell betöltenünk. Ennek megoldására osztálybetöltőt használunk, amivel be tudjuk tölteni egy lefordított Java fájlokat tartalmazó mappából az osztályokat. Itt még nem vagyunk készen, ugyanis a betöltött osztályok közül meg kell keresnünk azokat, amelyek a felhasználó tesztkódjában lettek definiálva. Ehhez szükségünk van ezeknek az osztályoknak a teljes elérési neveire, ami nem más, mint a teszt forrásfájl osztálystruktúrájának legkülső szintjén lévő osztályok nevei, prefixálva az opcionális csomagnévvel. Ezeknek az információknak a kinyeréséhez szintén a JavaParser-t használjuk. Az így meghatározott elérési nevek alapján már meg tudjuk kapni a hozzájuk tartozó tesztosztályokat az osztálybetöltőből, amit így már fel tud használni a JUnit a tesztek futtatására.
					\end{itemize}

				\subsubsection{JavaScript tesztelés sajátosságai}
					\begin{itemize}
						\item A megoldás, illetve a tesztek futtatásához a Node.js 10-es verzióját használjuk, egységteszt keretrendszernek pedig a Jasmine 3-as verzióját. A tesztelésre beküldött megoldás és teszt forráskódoknak meg kell felelniük az ezek által támasztott követelményeknek.
						\item Bár JavaScript esetén a forráskódokat bármilyen néven elmenthetjük, a konvenció szerinti néven mentjük el őket, a megoldást \texttt{index.js}, a tesztet pedig \texttt{index.spec.js} néven. Ez segíti a megoldó felhasználót, hiszen így a tesztkódban, a megoldás importálásakor nem kell tudnia, hogy honnan kell importálnia, elegendő a jelenlegi mappa elérési útját megadnia, ami \texttt{"."}.
						\item Mivel Node.js 10-es verzióját használjuk a futtatáshoz, így azokat a JavaScript funkciókat, elemeket használhatja a felhasználó, amelyek ebbe be vannak építve. Ezt ki szeretnénk terjeszteni a legújabbakra, ennek érdekében Babel-t és Core.js-t használunk. A Babel feladata, hogy a felhasználó JavaScript forráskódját, amiben a legújabb JavaScript elemek is fel lehetnek használva, átalakítsa olyan JavaScript kóddá, ami működése alapján teljesen megegyezik, viszont az újabb nyelvi elemeket, amelyeket a JavaScriptet futtató környezet még nem támogat, helyettesíti más, megegyező működésű konstrukciókkal. A Core.js feladata pedig, hogy a felhasználó JavaScript kódjában lehetővé tegye olyan osztályok, függvények használatát, amelyek részei, vagy részei lesznek a JavaScript standard függvénytárának, de a futtató környezet még nem tartalmazza ezeket. Ezt úgy éri el, hogy a kódban helyettesíti a megfelelő osztály- és függvényhasználatokat azoknak a Core.js szerinti implementációjával. A felhasználónak a kódban nem kell tennie semmi különöset, a Babel és a Core.js olyan módon került beállításra, hogy a szükséges módosítások a felhasználó forráskódjában automatikusan megtörténnek azok betöltésekor.
						\item A Jasminenak a tesztek futtatásához a teszteseteket tartalmazó fájl elérési útjára van szüksége, amely rendelkezésünkre áll. Az esetleges szintaktikai hibák már a tesztek futtatásakor derülnek ki.
					\end{itemize}

			\subsection{Egységes formátumon alapuló tesztelés}
				Ez a tesztelési módszer programozási nyelv-független, egységes formátumú tesztesetek alapján történő tesztfuttatást tesz lehetővé. Ez azt jelenti, hogy ha van egy programozási feladatra egy-egy teljesen megegyező megoldásom két különböző programozási nyelven, illetve vannak ilyen, egységes formátumú teszteseteim ezekhez a megoldásokhoz, akkor bármely programozási nyelven írt megoldásra lefuttatva a teszteket, azonos eredményeket kapok. Ennek eléréséhez egy olyan, közös interfészre van szükség, amely minden támogatott programozási nyelven megvalósítható. Ennek értelmében a teszteket nem egy programozási nyelv kódjaként írjuk meg, hanem definiálunk egy sémát a JSON szabvány felhasználásával, amely sémában reprezentálni tudjuk a tesztjeinket. A tesztek futtatásakor ezt a JSON objektumot át kell alakítanunk a tesztelendő megoldás programozási nyelve szerinti egységteszt keretrendszer kódjává, amellyel már le tudjuk futtatni a teszteket. Ehhez a JSON struktúrában lévő adatoknak egyértelműen megfeleltethetőnek kell lenniük a cél egységteszt keretrendszerben használható konstrukciónak. Ehhez a módszerhez szükséges a megoldás kódja, illetve a egységes teszteket tartalmazó JSON struktúra.
				
				Ezt a módszert minden esetben használjuk, de más módon. Amikor a felhasználó csak a megoldás kódját írja, azaz normál mód, illetve páros programozás, mint szoftverfejlesztési módszer használatakor, akkor úgy használjuk ezt a módszert, hogy a feladatot létrehozó felhasználó által a létrehozáskor megadott egységes formátumú teszteket küldjük be tesztelésre a megoldó felhasználó megoldási kódjával együtt, amikor a felhasználó tesztelést kér. Egyéb esetekben, vagyis a tesztvezérelt fejlesztés és a ping-pong módszer, mint szoftverfejlesztési módszerek használatakor bár a felhasználó maga írja a tesztkódot is, de a megoldás tényleges megfelelőségének ellenőrzése céljából lefutnak a létrehozáskor meghatározott egységes formátumú tesztek is.
				
				A módszer célja, hogy a megoldáskor egységes formában meg tudjuk jeleníteni, hogy milyen elvárásoknak kell megfelelni, az egységes teszteseteket lefuttatva jelentést kapjunk azok teljesüléséről, illetve, hogy a feladatot létrehozó felhasználónak csak egyszer kelljen leírnia a teszteseteket és az működjön minden programozási nyelvvel.

				A JSON struktúra tartalmazza az egységes formátumú teszteseteket és a tesztelendő függvény meghívási kódját. Ez a kód nem más, mint ahogyan a megoldásfüggvényünket meghívnánk az adott programozási nyelven, de még paraméterek nélkül, és ezt a megoldó felhasználónak kell megadnia a tesztelendő függvény beazonosítása érdekében. A teszteseteknél minden egyes tesztesethez tartozik egy szöveges leírás, egy paraméterlista, egy összehasonlító művelet és az elvárt érték. Az összehasonlító művelet lehet egyenlőség- vagy nem-egyenlőség vizsgálat. A paraméterekhez és az elvárt értékhez tartozik egy típus és egy érték. Típus lehet egész szám, dupla pontosságú lebegőpontos szám, logikai érték, szöveges érték, egész számok tömbje, dupla pontosságú lebegőpontos számok tömbje, logikai értékek tömbje vagy szöveges értékek tömbje. Az értékeknek a típus által támasztott szabályoknak kell megfelelniük, a tömböknél az egyes elemek "|" karakterrel vannak elválasztva. Egy lehetséges minta felépítés:
				\begin{minted}{json}
					{
						"functionCallCode": "calculateSomething",
						"testCases": [
							{
								"description": "it should return the ...",
								"parameters": [
									{
										"type": "integer",
										"value": "2"
									},
									{
										"type": "string array",
										"value": "one|two|three|four"
									},
									...
								],
								"matcher": "not equals",
								"expected": {
									"type": "boolean",
									"value": "true"
								}
							},
							...
						]
					}
				\end{minted}

				\subsubsection{A tesztelés közös lépései}
					\begin{enumerate}
						\item Megkapjuk a megoldás kódját, illetve az egységes, JSON formátumú tesztadatokat.
						\item Az egységes formátumú teszteseteket átalakítjuk a megoldáshoz használt programozási nyelv szerinti egységteszt keretrendszert felhasználó tesztkóddá:
						\begin{enumerate}
							\item Beillesztünk olyan kódokat, amelyek beimportálják a tesztkód számára szükséges függőségeket, így lehetővé teszik használatukat. Ez programozási nyelvenként változik.
							\item Előállítjuk minden egységes tesztesetnek az egységteszt keretrendszerbeli megfelelőjét. Pontosan megfeleltetünk minden megadható összehasonlító műveletet, illetve literált az egységteszt keretrendszerben, illetve a programozási nyelvben használható megfelelőjével. A tömbliterálok megfeleltetésénél az egyes elemeinek meghatározásához azoknak a megfeleltetését használjuk fel. Szöveges literáloknál figyelünk arra, hogy a nyelv sajátosságainak megfelelően escapeljük a benne lévő karaktereket az előállított forráskódban, így bármilyen karakter használható értékként. Tömb literáloknál lehetőséget adunk arra, hogy az elválasztó karaktert is fel lehessen használni az értékekben azáltal, hogy az escapelt elválasztókat nem elválasztóknak, hanem annak megfelelő karaktereknek feleltetjük meg. Ezek használatával már meghatározhatóak a szöveges leírások, a paraméterlisták, az összehasonlító műveletek és az elvárt értékek, így felépíthetőek a tesztesetek kódjai.
						\end{enumerate}
						\item A így létrejövő teszt- és az eredeti megoldáskód felhasználásával ugyanaz a folyamat megy végbe, mint az egységteszt keretrendszer kódján alapuló tesztelés módszerénél.
					\end{enumerate}

				\subsubsection{Java tesztelés sajátosságai}
					\begin{itemize}
						\item Az átalakítás során a JUnitot felhasználó tesztkód kerül előállításra.
						\item Importálásnál szükségünk van a JUnitból felhasználandó elemekre és Java osztályokra.
						\item Az összehasonlító műveletek megfeleltethetőségének megkönnyítése érdekében legeneráljuk és beillesztjük a kódba olyan összehasonlító műveletek implementációját, amelyeket a JUnit nem tartalmaz, viszont szükségünk van rájuk az egységes formátum maradéktalan támogatása érdekében.
					\end{itemize}
								
				\subsubsection{JavaScript tesztelés sajátosságai}
					\begin{itemize}
						\item Az átalakítás során a Jasminet felhasználó tesztkód kerül előállításra.
						\item Be kell importálnunk a megoldás kódjában lévő, exportált elemeket. A JavaScript nem ad natív lehetőséget arra, hogy kizárólag a fájlnév alapján beimportáljunk abból mindent, fel kell tudnunk sorolni egyesével az importálandó elemeket. Ennek feloldásaként azt a trükköt alkalmazzuk, hogy olyan kódot illesztünk be a tesztkódba, amely lefutásakor lekérdezi a megoldás fájljából exportált elemek nevét és értékét, és ezeket felhasználva elérhetővé teszi őket a tesztkódban. A megoldás CommonJS és ES6 modulrendszert használva is működik.
					\end{itemize}

		\section{Fejlesztőkörnyezet}
		TODO (rendszerkövetelmények, beállítás, futtatás)
		
		\section{Fejlesztési folyamat}

			\subsection{Csomagkezelés}
			TODO (npmről írni)
			
			\subsection{Verziókövetés}
			TODO (gitről írni)
			
			\subsection{Continuous Integration}
			TODO (Codeship lépésekről (lint, teszt, deploy) írni)
			
			\subsection{Continuous Delivery}
			TODO (Herokuról írni)
		
		\section{Tesztelés}
		TODO (rövid bevezetés)

			\subsection{Egységtesztek}
				A megoldás tesztelő rendszerhez egységtesztek készültek. Ezek a tesztek minden részletét letesztelik mind az egységteszt keretrendszer kódján alapuló, mind az egységes formátumon alapuló tesztelési módszernek. A programozási nyelvektől független működésű tesztesetek Java és JavaScript nyelvek használata esetén is meg lettek fogalmazva, ezen kívül le lettek tesztelve a programozási nyelv-specifikus esetek is. A tesztek a \texttt{methcodus-server/src/tester/tester.service.spec.ts} fájlban találhatóak, összesen 60 darab egységtesztet tartalmaz. A tesztek írására a Jasmine nevű egységteszt keretrendszert használtam. A leglényegesebb, letesztelt esetek a következőek:
				\begin{itemize}
					\item Egységteszt keretrendszer kódján alapuló tesztelés:
					\begin{itemize}
						\item Sikeres, sikertelen, illetve kihagyott állapotú tesztesetek
						\item Üres kód beküldése sikerrel, nulla teszteredménnyel végződik
						\item Egymásba ágyazott tesztstruktúrákon belüli tesztek is lefutnak
						\item JavaScript kódokban használható a CommonJS és az ES6 modulrendszer is, illetve minden modern JavaScript nyelvi elem és funkció
						\item Java kódokban használhatóak a csomagnevek
						\item Az ideiglenes forráskódokat tartalmazó mappa minden esetben kitörlődik
						\item Kivétel esetén sikertelen állapot
						\item Szintaktikai hiba, fordítási hiba és más hibák esetén hibaüzenet
					\end{itemize}
					\item Egységes formátumon alapuló tesztelés:
					\begin{itemize}
						\item Bármilyen támogatott paraméter típust elváró és önmagát visszaadó egyparaméteres függvény tesztelése a megfelelő eredménnyel zárul, bármely összehasonlító művelet esetén, igaz és hamis eredményt elváró esetekben is
						\item Nulla-, egy- és többparaméteres függvények is tesztelhetőek
						\item JavaScript megoldás kódból beimportáljuk, amik exportálva lettek
						\item Szöveges literálokat escapeljük, tömb literálokat escapelt elválasztó karakter esetén nem vágjuk el
					\end{itemize}
				\end{itemize}
			
			\subsection{Manuális tesztek}
			TODO (minden funkció lényegesebb kimeneteleire given-when-then leírás)
		
		\section{Továbbfejlesztési lehetőségek}
		TODO (Clean Code elvek támogatása, élő menet, élő menet páros programozással)

	\begin{thebibliography}{99}

		\addcontentsline{toc}{chapter}{Irodalomjegyzék}

		\bibitem{test} 
		\href{http://example.com}{TODO (kitölteni)} (2019.04.06.)

	\end{thebibliography}
	
	\chapter*{Mellékletek}

	\pagenumbering{gobble}
	\addcontentsline{toc}{chapter}{Mellékletek}

	\section*{DVD tartalma}
	TODO (tartalom, mappaszerkezet)

\end{document}
