\UseRawInputEncoding
\documentclass{elteikthesis}

\title{Methcodus}
\date{2019}
\author{Fityó Csaba}
\degree{programtervező informatikus BSc}
\supervisor{Nagy Sára}
\affiliation{mesteroktató}
\extsupervisor{Czeller Ildikó}
\extaffiliation{adattudós}
\university{Eötvös Loránd Tudományegyetem}
\faculty{Informatikai Kar}
\department{Algoritmusok és Alkalmazásaik}
\departmentSecondLine{Tanszék}
\city{Budapest}
\logo{elte-crest}

\begin{document}

	\documentlang{magyar}

	\maketitle

	\tableofcontents

	\chapter{Bevezetés}

		\section{Motiváció}
		TODO (témaválasztás indoklása)

		\section{Feladatleírás}
		TODO (röviden, közérthetően)

	\chapter{Felhasználói dokumentáció}

		\section{Felhasználási igények}
		TODO (mire való, kik mikor mire használják, összehasonlítás Codewarssal és hagyományos fejlesztőkörnyezettel)
		
		\section{Használati követelmények}
		TODO (rendszerkövetelmények, tudásbeli követelmények, elérési link)
		
		\section{Alkalmazás funkciói}
		TODO (minden funkció leírása képernyőképekkel, külön regisztrált és nem regisztrált felhasználóra, külön helyes és hibás használat)
		
		\section{Szoftverfejlesztési módszerek}
		TODO (tdd, párprogramozás bemutatása)

	\chapter{Fejlesztői dokumentáció}

		\section{Probléma specifikáció}
		TODO (célok meghatározása fejlesztői szemmel)

		\section{Tervezés}

			\subsection{Használati esetek}
			TODO (use case diagram)
			
			\subsection{Felület terv}
			TODO (mockupok)
			
			\subsection{Architektúra terv}
			TODO (rövid leírás a technikai megvalósításról)
		
		\section{Szerver architektúra}

			\subsection{Authentikáció}
			TODO (folyamata)
			
			\subsection{Adatbázis}
			TODO (modellek leírása és ábra, kapcsolatok)
			
			\subsection{Végpontok}
			TODO (leírásuk, működésük, kérés és válasz tartalma, hibalehetőségek)
			
			\subsection{Felhasznált technológiák}
			TODO (mit tud, mire és hogy használom: rest, node, typescript, nest, mongodb, docker, ubuntu, java, javascript, junit, jasmine, babel, core-js, websocket, socket.io, passport, jwt, ...)
			
			\subsection{Kód felépítése}
			TODO (osztálydiagram, mappaszerkezet, rétegek)
		
		\section{Kliens architektúra}

			\subsection{Authentikáció}
			TODO (folyamata)
			
			\subsection{Képernyők}
			TODO (leírásuk, komponenseik)
			
			\subsection{Komponensek}
			TODO (leírásuk, működésük, hibalehetőségek)
			
			\subsection{Felhasznált technológiák}
			TODO (mit tud, mire és hogy használom: angular, typescript, redux, spa, emarsys design system, ...)
			
			\subsection{Kód felépítése}
			TODO (komponensdiagram, mappaszerkezet, rétegek)
		
		\section{Komponensek közti kommunikáció}
		TODO (szerver, kliens és adatbázis összekötés, szekvenciadiagram egy összetettebb funkcióra)

		\section{A tesztelő rendszer működése}
			Az alkalmazás leglényegesebb része a tesztelő rendszer. A felhasználók által megoldandó programozási feladatok megoldása közben, illetve azok beküldésekor nyújt támpontot számukra azáltal, hogy kiértékeli a megoldásukat és egységes formájú jelentést készít annak állapotáról. Akár tesztvezérelt fejlesztéssel oldja meg a felhasználó a feladatot, akár nem, ez a rendszer felel a megoldás teszteléséért. A tesztelő rendszer a szerveroldalon található, HTTP kapcsolaton keresztül folyik a kommunikáció. Megkapjuk a teszteléshez szükséges adatokat, elvégezzük a teszteket, utána pedig válaszolunk a teszteredményekkel.
			
			Miután megérkeznek HTTP kérésen keresztül a megfelelő adatok, elindítjuk a tesztelést külön folyamatban parancssori programként, a tesztelendő megoldás programozási nyelve szerinti, azon a nyelven írt tesztelő program indításával. Java esetén a \texttt{java}, JavaScript esetén pedig a \texttt{node} parancsot használjuk erre, a teszteléshez szükséges adatokat pedig környezeti változókon keresztül, szövegesen kapja meg a tesztelő. Miután a tesztelő elvégezte feladatát, tudatnia kell az eredményeket az őt hívó szülőfolyamattal. Sikeres tesztelés esetén kiírja a standard kimenetre a teszteredményeket. Hiba esetén kilépési kódokat használunk:
			\begin{itemize}
				\setlength\itemsep{-0.5em}
				\item[1:] a beküldött kódokban lévő szintaktikai hibát jelez
				\item[2:] a beküldött kódokban lévő fordítási hibát jelez
				\item[255:] egyéb, ismeretlen hiba
			\end{itemize}
			A tesztelő folyamat terminálásakor, a szülőfolyamatban kiolvassuk a standard kimenetet, illetve a kilépési kódot. Ezek alapján, illetve hiba esetén egy hibaüzenetet előállítva küldjük vissza a HTTP választ, ami alapján megjelenítjük a felhasználónak a megoldása állapotát. TODO (felületen lévő tesztelési dolgokról írni ide?)
		
			A tesztek futtatására két mód van. Az egyik módszer az egységteszt keretrendszer kódján alapuló tesztelés, másik pedig az egységes formátumon alapuló tesztelés. Mindkét módszer képes együttműködni Java és JavaScript nyelven írt kódokkal.

			\subsection{Egységteszt keretrendszer kódján alapuló tesztelés}
				Ez a tesztelési módszer egy, a feladat megoldására használt programozási nyelvvel együttműködő egységteszt keretrendszert használó tesztkód alapján történő tesztelésre használható. Szükséges hozzá a megoldás kódja, illetve az egységteszt keretrendszert felhasználó tesztkód. Ezt a módszert akkor használjuk, amikor a felhasználó maga írja a tesztkódot is, azaz a tesztvezérelt fejlesztés, illetve a ping-pong módszer (tesztvezérelt fejlesztés és párprogramozás együttesen), mint szoftverfejlesztési módszer használatával történő megoldáskor. Célja, hogy a tesztkódban lévő, a megoldást tesztelő teszteseteket lefuttatva jelentést kapjunk azok teljesüléséről.

				\subsubsection{A tesztelés közös lépései}
					\begin{enumerate}
						\item Megkapjuk a tesztelendő megoldás kódját, illetve a tesztkódot.
						\item Létrehozunk egy ideiglenes mappát, amiben a teszteléshez szükséges forráskódokat fogjuk tárolni. A mappa nevének egyedinek kell lennie. Ez biztosítja azt, hogy egyidejűleg több felhasználó is tudja használni az alkalmazást feladatok megoldására, ütközések nélkül. Ennek érdekében a mappanevet a következő minta adja: \texttt{\{HASH\}\_\{TIME\}}, ahol \texttt{\{HASH\}} a megoldás és a teszt forráskódok konkatenációjának az MD5 kódolási algoritmus által képzett kódja, illetve \texttt{\{TIME\}} a jelenlegi Unix-idő milliszekundumokban. Így azonos milliszekundumban is futtatható több tesztelés, amennyiben nem egyeznek meg teljesen a tesztelendő forráskódok.
						\item Kiírjuk a forráskódokat külön fájlokba az előbb létrehozott mappán belül. Egyes programozási nyelveknél fontos lehet, hogy hogyan nevezzük el a fájlokat, ezért erre figyelünk (lásd lentebb, az egyes nyelvek sajátosságainál).
						\item Futtatjuk a tesztkódban lévő teszteket a megfelelő egységteszt keretrendszer segítségével. A teszteseteken belül történő futtatási hibák (exception) esetén sikertelennek nyilvánítjuk az érintett teszteseteket, nem állunk meg a teszteléssel. Bármilyen más, a tesztelés folytatását lehetetlenné tevő hiba (pl. szintaktikai vagy fordítási hiba) esetén megszakítjuk a tesztelési folyamatot, hibával térünk vissza. A tesztek eredményeit egységes, általános formátumban szeretnénk megkapni, erre a JSON szabványt használjuk. Ennek érdekében felüldefiniáljuk az egységteszt keretrendszer alapértelmezett teszteredmény-jelentési módszerét. Ennek értelmében minden teszteset lefutása után legeneráljuk a keretrendszer által adott információk alapján az adott teszteset egységes eredményét, ami a teszteset nevéből és állapotából áll. Egy teszteset állapota lehet sikeres, sikertelen vagy kihagyott. Az összes tesztesetről előáll egy ilyen eredmény. Az így létrehozott JSON objektumot használjuk fel később az eredmények megjelenítésére a felhasználónak. A teszteredmények minta felépítése:
						\begin{minted}{json}
							[
								{ "name": "first test", "status": "pass" },
								{ "name": "second test", "status": "fail" },
								...
							]
						\end{minted}
						\item Végül töröljük a forráskódok tárolására használt ideiglenes mappát. Ezt akkor is megtesszük, ha bármelyik lépésben hiba történik.
					\end{enumerate}

				\subsubsection{Java tesztelés sajátosságai}
					\begin{itemize}
						\item A megoldás, illetve a tesztek fordításához és futtatásához a Java SE Development Kit 12-es verzióját használjuk, egységteszt keretrendszernek pedig a JUnit 5-ös verzióját. A tesztelésre beküldött megoldás és teszt forráskódoknak meg kell felelniük az ezek által támasztott követelményeknek.
						\item Fontos szerepe van Java esetén, hogy a forrásfájlokat milyen néven mentjük el, ennek figyelmen kívül hagyása esetén a fordítási folyamat hibával térne vissza. Ha a forrásfájl osztálystruktúrájának legkülső szintjén van publikus osztály, interfész vagy felsorolási típus, akkor a fájl nevének meg kell egyeznie ennek a nevével. Egyéb esetben nincs megkötés a fájlnévvel kapcsolatban. Ezt a szabályt használjuk fel a fájlnév meghatározásakor. A forráskódban definiált osztálynevek kinyeréséhez a JavaParser Java forráskód elemzőt használjuk. A szintaktikai hibák detektálásához szintén a JavaParser-t használjuk.
						\item Le kell fordítanunk a Java forrásfájlokat, hogy használni tudjuk őket a tesztek futtatásakor. Ehhez a Java Compiler API-t használjuk, ami a Java fordítót használja fel. A lefordított fájlokat a forrásfájlokban opcionálisan deklarálható package-információ szerinti konyvtárstruktúrába helyezzük, a forráskódok ideiglenes mappájába. Ebben a lépésben detektálni tudjuk a fordítási hibákat.
						\item A JUnit-nak a tesztesetek lefuttatásához szüksége van az azokat tartalmazó osztályokra, mint objektumokra, és ehhez ezeknek az osztályoknak be kell töltve lenniük a tesztelő program használatára. Legtöbb Java program esetében már futtatáskor meg tudjuk adni az összes, a program által használandó osztályt. Itt nem ez a helyzet, mert a felhasználótól érkező megoldás és teszt csak a program futása alatt kerül használható formába, ezért ezeket futás alatt, dinamikusan kell betöltenünk. Ennek megoldására osztálybetöltőt használunk, amivel be tudjuk tölteni egy lefordított Java fájlokat tartalmazó mappából az osztályokat. Itt még nem vagyunk készen, ugyanis a betöltött osztályok közül meg kell keresnünk azokat, amelyek a felhasználó tesztkódjában lettek definiálva. Ehhez szükségünk van ezeknek az osztályoknak a teljes elérési neveire, ami nem más, mint a teszt forrásfájl osztálystruktúrájának legkülső szintjén lévő osztályok nevei, prefixálva az opcionális package névvel. Ezeknek az információknak a kinyeréséhez szintén a JavaParser-t használjuk. Az így meghatározott elérési nevek alapján már meg tudjuk kapni a hozzájuk tartozó tesztosztályokat az osztálybetöltőből, amit így már fel tud használni a JUnit a tesztek futtatására.
					\end{itemize}

				\subsubsection{JavaScript tesztelés sajátosságai}
					\begin{itemize}
						\item A megoldás, illetve a tesztek futtatásához a Node.js 10-es verzióját használjuk, egységteszt keretrendszernek pedig a Jasmine 3-as verzióját. A tesztelésre beküldött megoldás és teszt forráskódoknak meg kell felelniük az ezek által támasztott követelményeknek.
						\item Bár JavaScript esetén a forráskódokat bármilyen néven elmenthetjük, a konvenció szerinti néven mentjük el őket, a megoldást \texttt{index.js}, a tesztet pedig \texttt{index.spec.js} néven. Ez segíti a megoldó felhasználót, hiszen így a tesztkódban, a megoldás importálásakor nem kell tudnia, hogy honnan kell importálnia, elegendő a jelenlegi mappa elérési útját megadnia, ami \texttt{"."}.
						\item Mivel Node.js 10-es verzióját használjuk a futtatáshoz, így azokat a JavaScript funkciókat, elemeket használhatja a felhasználó, amelyek ebbe be vannak építve. Ezt ki szeretnénk terjeszteni a legújabbakra, ennek érdekében Babel-t és Core.js-t használunk. A Babel feladata, hogy a felhasználó JavaScript forráskódját, amiben a legújabb JavaScript elemek is fel lehetnek használva, átalakítsa olyan JavaScript kóddá, ami működése alapján teljesen megegyezik, viszont az újabb nyelvi elemeket, amelyeket a JavaScript-et futtató környezet még nem támogat, helyettesíti más, megegyező működésű konstrukciókkal. A Core.js feladata pedig, hogy a felhasználó JavaScript kódjában lehetővé tegye olyan osztályok, függvények használatát, amelyek részei, vagy részei lesznek a JavaScript standard függvénytárának, de a futtató környezet még nem tartalmazza ezeket. Ezt úgy éri el, hogy a kódban helyettesíti a megfelelő osztály- és függvényhasználatokat azoknak a Core.js szerinti implementációjával. A felhasználónak a kódban nem kell tennie semmi különöset, a Babel és a Core.js olyan módon került beállításra, hogy a szükséges módosítások a felhasználó forráskódjában automatikusan megtörténnek azok betöltésekor.
						\item A Jasmine-nak a tesztek futtatásához a teszteseteket tartalmazó fájl elérési útjára van szüksége, amely rendelkezésünkre áll. Az esetleges szintaktikai hibák már a tesztek futtatásakor derülnek ki.
					\end{itemize}

		\section{Fejlesztőkörnyezet}
		TODO (rendszerkövetelmények, beállítás, futtatás)
		
		\section{Fejlesztési folyamat}

			\subsection{Csomagkezelés}
			TODO (npm)
			
			\subsection{Verziókövetés}
			TODO (git)
			
			\subsection{Continuous Integration}
			TODO (codeship: lint, teszt, deploy)
			
			\subsection{Continuous Delivery}
			TODO (heroku)
		
		\section{Tesztelés}

			\subsection{Egységtesztek}
			TODO (lib leírás, tesztelés eredménye)
			
			\subsection{Manuális tesztek}
			TODO (minden funkció minden kimenetelére given-when-then leírás)
		
		\section{Továbbfejlesztési lehetőségek}
		TODO (clean code, élő menet, párprogramozásos élő menet)

	\begin{thebibliography}{99}

		\addcontentsline{toc}{chapter}{Irodalomjegyzék}

		\bibitem{test} 
		\href{http://example.com}{Example.com} (2019.04.06.)

	\end{thebibliography}
	
	\chapter*{Mellékletek}

	\pagenumbering{gobble}
	\addcontentsline{toc}{chapter}{Mellékletek}

	\section*{DVD tartalma}
	TODO (tartalom, mappaszerkezet)

\end{document}
